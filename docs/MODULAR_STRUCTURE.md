# Модульная структура Telegram Remote Monitoring & Management Bot

## Обзор

Проект был реорганизован в модульную структуру для лучшей организации кода и упрощения поддержки. Основной файл `bot.py` теперь содержит только логику обработки Telegram команд и callback'ов, а вся остальная функциональность вынесена в отдельные модули.

## Структура файлов

```
tg_system_bot/
├── bot.py              # Основной файл бота (обработка команд и callback'ов)
├── config.py           # Конфигурация и настройки
├── auth.py             # Аутентификация и авторизация
├── system_monitor.py   # Мониторинг системы и выполнение команд
├── formatters.py       # Форматирование данных для отображения
├── keyboards.py        # Клавиатуры и callback данные
├── monitoring.py       # Фоновый мониторинг и уведомления
├── main.py            # Старый монолитный файл (для совместимости)
├── config.example.py  # Пример конфигурации
├── requirements.txt   # Зависимости Python
├── run_bot.sh        # Скрипт запуска
└── README.md         # Основная документация
```

## Описание модулей

### 1. `config.py` - Конфигурация
- Загрузка переменных окружения
- Валидация обязательных настроек
- Константы для пороговых значений уведомлений
- Настройки логирования

**Основные функции:**
- Автоматическая загрузка `.env` файла
- Fallback на `config.py` если переменные окружения не установлены
- Валидация `BOT_TOKEN` и `ADMIN_ID`

### 2. `auth.py` - Аутентификация
- Проверка прав доступа администратора
- Декоратор `@admin_only` для команд
- Функция `admin_only_callback` для callback'ов

**Основные функции:**
- `is_admin(user_id)` - проверка является ли пользователь администратором
- `admin_only` - декоратор для ограничения доступа к командам
- `admin_only_callback` - проверка прав для callback запросов

### 3. `system_monitor.py` - Мониторинг системы
- Сбор информации о системе (CPU, память, диски, процессы)
- Выполнение системных команд
- Работа с Docker контейнерами
- Сетевая информация

**Основные классы данных:**
- `SystemStatus` - общая информация о системе
- `ProcessInfo` - информация о процессах
- `DockerInfo` - информация о Docker контейнерах
- `NetworkInfo` - сетевая информация

**Основные функции:**
- `gather_system_status()` - сбор полной информации о системе
- `get_top_processes()` - топ процессов по использованию ресурсов
- `get_docker_info()` - информация о Docker контейнерах
- `run_command()` - выполнение системных команд
- `sudo_*` функции - выполнение привилегированных команд

### 4. `formatters.py` - Форматирование
- Преобразование данных в HTML для Telegram
- Форматирование размеров файлов и времени
- Рендеринг различных типов отчетов

**Основные функции:**
- `fmt_bytes()` - форматирование размеров в человекочитаемый вид
- `fmt_timedelta()` - форматирование временных интервалов
- `render_status_html()` - рендеринг статуса системы
- `render_processes_html()` - рендеринг списка процессов
- `render_docker_html()` - рендеринг информации о Docker
- `render_network_html()` - рендеринг сетевой информации

### 5. `keyboards.py` - Клавиатуры
- Определение callback данных
- Создание inline клавиатур
- Константы для callback'ов

**Основные компоненты:**
- `CBA` enum - коды callback действий
- `kb_main_menu()` - главное меню
- `kb_confirm()` - клавиатура подтверждения
- `kb_services_action()` - действия с сервисами
- `kb_docker_action()` - действия с Docker

### 6. `monitoring.py` - Фоновый мониторинг
- Отслеживание критических параметров системы
- Отправка уведомлений администратору
- Регулярные отчеты о состоянии

**Основные функции:**
- `background_monitoring()` - фоновый мониторинг с уведомлениями
- `scheduled_status()` - регулярные отчеты о состоянии

### 7. `bot.py` - Основной файл бота
- Обработка Telegram команд
- Обработка callback запросов
- Настройка и запуск бота
- Инициализация фоновых задач

**Основные компоненты:**
- Обработчики команд (`/start`, `/status`, `/services`, etc.)
- Обработчики callback'ов для inline кнопок
- Настройка команд бота для Telegram клиента
- Запуск фонового мониторинга

## Преимущества модульной структуры

### 1. Улучшенная организация кода
- Каждый модуль отвечает за свою область функциональности
- Легче найти и изменить нужную часть кода
- Упрощено тестирование отдельных компонентов

### 2. Переиспользование кода
- Функции форматирования можно использовать в разных местах
- Системный мониторинг можно использовать независимо от бота
- Конфигурация централизована

### 3. Упрощение поддержки
- Изменения в одном модуле не влияют на другие
- Легче добавлять новую функциональность
- Проще отлаживать проблемы

### 4. Масштабируемость
- Можно легко добавить новые модули
- Возможность создания альтернативных интерфейсов
- Поддержка плагинов в будущем

## Миграция с монолитного файла

Если у вас есть код, использующий старый `main.py`, вы можете:

1. **Продолжить использовать `main.py`** - он остался для совместимости
2. **Переключиться на `bot.py`** - обновите скрипты запуска
3. **Импортировать отдельные модули** - используйте функции из модулей в своих скриптах

## Примеры использования модулей

### Импорт функций мониторинга
```python
from system_monitor import gather_system_status, get_top_processes
from formatters import render_status_html

# Получить статус системы
status = gather_system_status()
print(render_status_html(status))

# Получить топ процессов
processes = get_top_processes(10)
for proc in processes:
    print(f"{proc.name}: {proc.cpu_percent}% CPU")
```

### Использование форматирования
```python
from formatters import fmt_bytes, fmt_timedelta

# Форматирование размеров
size = 1024 * 1024 * 1024  # 1GB
print(fmt_bytes(size))  # "1.0GB"

# Форматирование времени
from datetime import timedelta
uptime = timedelta(hours=2, minutes=30, seconds=45)
print(fmt_timedelta(uptime))  # "2h 30m 45s"
```

### Проверка прав доступа
```python
from auth import is_admin

user_id = 123456789
if is_admin(user_id):
    print("Пользователь является администратором")
```

## Заключение

Модульная структура делает код более организованным, поддерживаемым и расширяемым. Каждый модуль имеет четко определенную ответственность, что упрощает разработку и отладку. При этом сохраняется полная совместимость с существующим кодом через файл `main.py`. 