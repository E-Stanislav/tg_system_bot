#!/usr/bin/env bash
# Outline / Shadowsocks Docker VPN Audit Script
# Version: 1.0.0
# Author: Generated by AI (Senior DevOps/Security Engineer role)
# License: MIT

set -euo pipefail
IFS=$'\n\t'

# Проверка ОС
if [[ "$(uname -s)" != "Linux" ]]; then
  echo "[ERROR] Этот скрипт предназначен только для Linux."
  exit 1
fi

################################################################################
# ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
################################################################################
VERSION="1.0.0"
START_TS="$(date +%s)"
SCRIPT_NAME="${0##*/}"
COLOR=1
JSON_ONLY=0
RUNS=3
TIMEOUT_SEC=30
DO_SPEEDTEST=1
CONTAINER_NAME="outline-server" # можно переопределить флагом
EXPECT_LIMITS=0
POLICY_ALLOW_IPV6=0  # 0 => IPv6 не обязателен; наличие глобального IPv6 помечаем WARN
TMP_DIR="/tmp/outline_audit_$$"
mkdir -p "$TMP_DIR"
RESULT_JSON_ENTRIES=()
TESTS=()
TEST_NAMES=()
TEST_INDEX=()
SPEEDTEST_RESULTS=()
RECOMMENDATIONS=()
LOG_PATTERN_FATAL_FAIL_REGEX='fatal|panic'
LOG_PATTERN_WARN_REGEX='warn|error|fail|restart'
REQUIRED_COMMANDS=(docker curl awk sed grep cut tr ss ip ping head tail date uname cat wc sort uniq printf)
OPTIONAL_COMMANDS=(jq dig nc nmap speedtest speedtest-cli timeout column tput)
MISSING_CMDS=()
EXIT_CODE=0
SELF_CHECK_STATUS="UNKNOWN"

# Ассоциативные массивы (bash 4+)
declare -A TEST_STATUS TEST_MSG TEST_KV TEST_DURATION_MS

################################################################################
# УТИЛИТЫ: Цвета / логгирование
################################################################################
init_colors() {
  if [[ $COLOR -eq 0 ]] || [[ ! -t 1 ]]; then
    RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""; BOLD=""; RESET=""
  else
    RED="\033[31m"; GREEN="\033[32m"; YELLOW="\033[33m"; BLUE="\033[34m"; MAGENTA="\033[35m"; CYAN="\033[36m"; BOLD="\033[1m"; RESET="\033[0m"
  fi
}

log() { echo -e "$*" >&2; }

mask_secrets() {
  # Маскируем ss:// ключи (оставляем начало + конец)
  sed -E 's#ss://([A-Za-z0-9+/_=-]{4})[A-Za-z0-9+/_=-]+(@)#ss://\1***\2#g'
}

run_or_warn() {
  # Выполняет команду, при ошибке не прерывает скрипт
  local desc="$1"; shift || true
  if ! "$@" >"$TMP_DIR/cmd_stdout" 2>"$TMP_DIR/cmd_stderr"; then
    echo "WARN: $desc: $(tr '\n' ' ' <"$TMP_DIR/cmd_stderr")" >&2
    return 1
  fi
  cat "$TMP_DIR/cmd_stdout"
}

json_escape() { # грубое экранирование
  local s="$1"
  s=${s//\\/\\\\}; s=${s//"/\\"}; s=${s//$'\n'/\\n}; s=${s//$'\r'/}; echo -n "$s"
}

################################################################################
# РЕГИСТРАЦИЯ ТЕСТОВ
################################################################################
register_test() {
  local id="$1"; local name="$2"
  TESTS+=("test_${id}")
  TEST_NAMES+=("$name")
  TEST_INDEX["$id"]=${#TESTS[@]}-1
}

record_result() {
  local id="$1" status="$2" msg="$3"; shift 3
  TEST_STATUS["$id"]="$status"
  TEST_MSG["$id"]="$msg"
  local kv="" k v
  for pair in "$@"; do
    k="${pair%%=*}"; v="${pair#*=}"; kv+="\"$(json_escape "$k")\":\"$(json_escape "$v")\",";
  done
  kv="${kv%,}"
  TEST_KV["$id"]="$kv"
}

################################################################################
# ПАРСИНГ АРГУМЕНТОВ
################################################################################
print_help() {
  cat <<EOF
Usage: $SCRIPT_NAME [options]
  --json-only                  Только JSON вывод
  --runs N                     Количество прогонов speedtest (default $RUNS)
  --timeout-sec T              Таймаут для отдельных сетевых тестов (default $TIMEOUT_SEC)
  --no-speedtest               Отключить speedtest
  --container-name NAME        Имя контейнера Outline (default outline-server)
  --expect-limit-resources     Ожидать лимиты ресурсов Docker
  --allow-ipv6                 IPv6 допустим (не будет WARN)
  --no-color                   Отключить ANSI цвета
  --help                       Показать эту справку
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --json-only) JSON_ONLY=1; shift ;;
    --runs) RUNS="${2:-3}"; shift 2;;
    --timeout-sec) TIMEOUT_SEC="${2:-30}"; shift 2;;
    --no-speedtest) DO_SPEEDTEST=0; shift ;;
    --container-name) CONTAINER_NAME="${2:-outline-server}"; shift 2;;
    --expect-limit-resources) EXPECT_LIMITS=1; shift ;;
    --allow-ipv6) POLICY_ALLOW_IPV6=1; shift ;;
    --no-color) COLOR=0; shift ;;
    --help) print_help; exit 0;;
    *) echo "Unknown arg: $1"; print_help; exit 1;;
  esac
done

init_colors

################################################################################
# ИНИЦИАЛИЗАЦИЯ ОКРУЖЕНИЯ
################################################################################
init_environment() {
  local missing=()
  for c in "${REQUIRED_COMMANDS[@]}"; do
    command -v "$c" >/dev/null 2>&1 || missing+=("$c")
  done
  if ((${#missing[@]})); then
    MISSING_CMDS=("${missing[@]}")
  fi
  for c in "${OPTIONAL_COMMANDS[@]}"; do
    command -v "$c" >/dev/null 2>&1 || true
  done
}

################################################################################
# ТЕСТЫ
################################################################################

# 1. System Info
set +u
register_test sysinfo "Системная информация"
register_test public_ip "Публичный IP"
register_test ipv6 "IPv6"
register_test container "Контейнер Outline"
register_test image_ver "Версия образа"
register_test ss_port "Порт Shadowsocks"
register_test firewall "Firewall"
register_test routes "Маршруты"
register_test dns "DNS"
register_test ipv6_leak "IPv6 Leak"
register_test speedtest "Speedtest"
register_test latency "Latency"
register_test logs "Логи контейнера"
register_test cresources "Ресурсы контейнера"
register_test openports "Открытые порты"
register_test masking "Маскирование секретов"
register_test jsonbuild "Сборка JSON"
register_test summary "Итоговый Summary"
register_test selfcheck "Self Check"
set -u
# 2. Public IP
# 3. IPv6 Presence
# 4. Docker Container
# 5. Image Version / Update
# 6. Shadowsocks Port
# 7. Firewall
# 8. Routes
# 9. DNS Leak
# 10. IPv6 Leak
# 11. Speedtest
# 12. Latency
# 13. Logs
# 14. Container Resources
# 15. Open Ports
# 16. Secret Masking
# 17. Aggregated JSON Build
# 18. Summary
# 19. Self Check

#############################################
# Реализации тестов
#############################################

test_sysinfo() {
  local id=sysinfo; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local host kern uptime load cpu_mem
  host=$(hostname 2>/dev/null || echo unknown)
  kern=$(uname -r 2>/dev/null || echo unknown)
  uptime=$(awk -F. '{printf "%d",$1}' /proc/uptime 2>/dev/null || echo 0)
  local loadavg=$(cut -d' ' -f1-3 /proc/loadavg 2>/dev/null)
  local cpu_usage="$(awk -v FS=' ' '/cpu /{u=$2+$4; t=$2+$4+$5; if (prev_t){printf "%.2f", ( (u-prev_u)/(t-prev_t))*100}; prev_u=u; prev_t=t}' <(grep '^cpu ' /proc/stat; sleep 0.5; grep '^cpu ' /proc/stat) 2>/dev/null || echo unknown)"
  local mem_line=$(grep -E 'Mem(Total|Free|Available):' /proc/meminfo 2>/dev/null | paste -sd' ' -)
  local mem_total=$(echo "$mem_line" | awk '{for(i=1;i<=NF;i++){if($i~"MemTotal:") print $(i+1)}}')
  local mem_avail=$(echo "$mem_line" | awk '{for(i=1;i<=NF;i++){if($i~"MemAvailable:") print $(i+1)}}')
  local mem_perc="unknown"
  if [[ -n "$mem_total" && -n "$mem_avail" ]]; then
    mem_perc=$(awk -v t=$mem_total -v a=$mem_avail 'BEGIN{printf "%.2f", (t-a)/t*100}')
  fi
  record_result "$id" OK "Собрана системная информация" hostname=$host kernel=$kern uptime_sec=$uptime load="$loadavg" cpu_percent="$cpu_usage" mem_used_percent="$mem_perc"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_public_ip() {
  local id=public_ip; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local ip="" source="" geo="" asn="" status=OK msg=""; local ipv4_services=(ifconfig.me icanhazip.com)
  for s in "${ipv4_services[@]}"; do
    ip=$(curl -4 -m 5 -fsS "$s" || true)
    if [[ $ip =~ ^[0-9]+(\.[0-9]+){3}$ ]]; then source=$s; break; fi
  done
  if [[ -z $ip ]]; then
    status=WARN; msg="Не удалось получить публичный IPv4"
  else
    msg="Получен IPv4 $ip"
    # Гео ASN
    local info
    info=$(curl -m 5 -fsS "https://ipinfo.io/$ip/json" || true)
    if [[ -n $info ]]; then
      geo=$(echo "$info" | grep 'country' | head -1 | awk -F '"' '{print $4}')
      asn=$(echo "$info" | grep 'org' | head -1 | awk -F '"' '{print $4}')
    else
      info=$(curl -m 5 -fsS "http://ip-api.com/json/$ip" || true)
      if [[ -n $info ]]; then
        geo=$(echo "$info" | grep -o '"country":"[^"]*"' | head -1 | cut -d'"' -f4)
        asn=$(echo "$info" | grep -o '"as":"[^"]*"' | head -1 | cut -d'"' -f4)
      else
        status=INFO; msg+=" (без гео)"
      fi
    fi
  fi
  record_result "$id" "$status" "$msg" ip="$ip" source="$source" country="$geo" asn="$asn"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_ipv6() {
  local id=ipv6; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local ipv6=$(ip -6 addr show scope global 2>/dev/null | awk '/inet6 /{print $2}' | cut -d'/' -f1 | head -1 || true)
  local status=OK msg="IPv6 отсутствует (нормально)"
  if [[ -n $ipv6 ]]; then
    if [[ $POLICY_ALLOW_IPV6 -eq 1 ]]; then
      status=INFO; msg="Найден IPv6 $ipv6"
    else
      status=WARN; msg="Найден глобальный IPv6 $ipv6 (политика не разрешает)"
    fi
  fi
  record_result "$id" "$status" "$msg" ipv6="$ipv6"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_container() {
  local id=container; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local status=OK msg="" cid state restarts image startedAt
  cid=$(docker ps -aqf "name=^${CONTAINER_NAME}$" 2>/dev/null || true)
  if [[ -z $cid ]]; then
    record_result "$id" FAIL "Контейнер не найден" name="$CONTAINER_NAME"; TEST_DURATION_MS[$id]=0; return
  fi
  state=$(docker inspect -f '{{.State.Status}}' "$cid" 2>/dev/null || echo unknown)
  restarts=$(docker inspect -f '{{.RestartCount}}' "$cid" 2>/dev/null || echo 0)
  image=$(docker inspect -f '{{.Config.Image}}' "$cid" 2>/dev/null || echo unknown)
  startedAt=$(docker inspect -f '{{.State.StartedAt}}' "$cid" 2>/dev/null || echo unknown)
  if [[ $state != running ]]; then status=FAIL; msg="Состояние: $state"; else msg="Контейнер работает"; fi
  record_result "$id" "$status" "$msg" id="$cid" image="$image" restarts="$restarts" startedAt="$startedAt"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_image_ver() {
  local id=image_ver; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local cid=$(docker ps -aqf "name=^${CONTAINER_NAME}$" 2>/dev/null || true)
  if [[ -z $cid ]]; then
    record_result "$id" INFO "Нет контейнера"; TEST_DURATION_MS[$id]=0; return
  fi
  local image=$(docker inspect -f '{{.Config.Image}}' "$cid" 2>/dev/null || echo unknown)
  local local_digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$image" 2>/dev/null || true)
  local status=OK msg="Digest локальный"
  # Попытка pull
  if ! pull_out=$(docker pull -q "$image" 2>&1); then
    status=INFO; msg="Не удалось проверить обновление"
  else
    local new_digest=$(docker inspect --format='{{index .RepoDigests 0}}' "$image" 2>/dev/null || true)
    if [[ -n $local_digest && -n $new_digest && $local_digest != "$new_digest" ]]; then
      status=WARN; msg="Доступно обновление образа"
      RECOMMENDATIONS+=("Обновить образ $image до последнего digest")
    fi
  fi
  record_result "$id" "$status" "$msg" image="$image" local_digest="$local_digest"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_ss_port() {
  local id=ss_port; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local cid=$(docker ps -aqf "name=^${CONTAINER_NAME}$" 2>/dev/null || true)
  local status=OK msg="" port="" proto=tcp
  if [[ -z $cid ]]; then
    record_result "$id" FAIL "Контейнер не найден"; TEST_DURATION_MS[$id]=0; return
  fi
  port=$(docker inspect "$cid" 2>/dev/null | grep -E '"[0-9]+/tcp"' | grep -o '"HostPort": "[0-9]+"' | head -1 | grep -o '[0-9]+' || true)
  if [[ -z $port ]]; then
    # Попытка из переменных окружения
    port=$(docker inspect -f '{{range $e,$v := .Config.Env}}{{println $v}}{{end}}' "$cid" | grep -E '^(PORT|SERVER_PORT)=' | head -1 | cut -d'=' -f2 || true)
  fi
  if [[ -z $port ]]; then
    record_result "$id" FAIL "Не удалось определить порт"; TEST_DURATION_MS[$id]=0; return
  fi
  local listen=$(ss -ltnp 2>/dev/null | grep -E ":$port " || true)
  if [[ -z $listen ]]; then status=FAIL; msg="Порт $port не слушает"; else msg="Порт $port слушает"; fi
  if command -v nc >/dev/null 2>&1; then
    if ! nc -z -w2 127.0.0.1 "$port" 2>/dev/null; then status=FAIL; msg+=" (TCP handshake fail)"; fi
  fi
  record_result "$id" "$status" "$msg" port="$port"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_firewall() {
  local id=firewall; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local ipt nft status=INFO msg="Собраны правила" unexpected="" port_allowed=""
  ipt=$(run_or_warn "iptables" iptables -S 2>/dev/null || true)
  nft=$(run_or_warn "nft" nft list ruleset 2>/dev/null || true)
  local ss_port=$(echo "${TEST_KV[ss_port]}" | grep -o '"port":"[0-9]+"' | grep -o '[0-9]+' || true)
  if [[ -n $ipt ]]; then
    if [[ -n $ss_port ]]; then
      if echo "$ipt" | grep -qi "--dport $ss_port"; then port_allowed=1; fi
    fi
  fi
  if [[ -n $ipt ]]; then status=OK; fi
  # Эвристика неожиданных разрешённых портов
  local open_ports=$(ss -ltn 2>/dev/null | awk 'NR>1{gsub(/.*:/,"");print $4}' | sort -n | uniq | tr '\n' ' ')
  for p in $open_ports; do
    if [[ "$p" != "22" && "$p" != "$ss_port" ]]; then unexpected+="$p,"; fi
  done
  if [[ -n $unexpected ]]; then status=WARN; msg="Найдены неожиданные порты"; RECOMMENDATIONS+=("Ограничить firewall до портов 22,$ss_port") ; fi
  record_result "$id" "$status" "$msg" unexpected_ports="${unexpected%,}" ss_port="$ss_port"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_routes() {
  local id=routes; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local def_route priv_routes
  def_route=$(ip route show default 2>/dev/null | head -1 | tr -s ' ' | cut -d' ' -f1-5)
  priv_routes=$(ip route | grep -E '(^| )((10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1]))|169\.254\.)' | tr '\n' ';' || true)
  record_result "$id" INFO "Маршруты собраны" default="$def_route" private="$priv_routes"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_dns() {
  local id=dns; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local resolv=$(grep -E '^nameserver' /etc/resolv.conf | awk '{print $2}' | tr '\n' ',' )
  local status=OK msg="DNS тест"; local used_servers="" qhosts=(google.com cloudflare.com example.com)
  if ! command -v dig >/dev/null 2>&1; then
    status=INFO; msg="dig недоступен"; record_result "$id" "$status" "$msg" resolv="$resolv"; TEST_DURATION_MS[$id]=0; return
  fi
  for h in "${qhosts[@]}"; do
    local ans=$(dig +time=3 +tries=1 +short "$h" 2>/dev/null | head -1)
    [[ -n $ans ]] || status=WARN
  done
  used_servers=$(dig +stats google.com 2>/dev/null | grep 'SERVER:' | awk '{print $3}' | tr -d '()' | tr '\n' ',')
  record_result "$id" "$status" "$msg" resolv="$resolv" servers="$used_servers"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_ipv6_leak() {
  local id=ipv6_leak; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local g6=$(ip -6 addr show scope global 2>/dev/null | awk '/inet6 /{print $2}' | cut -d'/' -f1 | head -1 || true)
  local status=OK msg="Нет IPv6 утечки"; if [[ -n $g6 && $POLICY_ALLOW_IPV6 -eq 0 ]]; then
    if ping -6 -c1 -w3 google.com >/dev/null 2>&1; then status=WARN; msg="Доступен глобальный IPv6 (возможная утечка)"; fi
  fi
  record_result "$id" "$status" "$msg" global_ipv6="$g6"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_speedtest() {
  local id=speedtest; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  if [[ $DO_SPEEDTEST -eq 0 ]]; then record_result "$id" INFO "Speedtest отключен"; TEST_DURATION_MS[$id]=0; return; fi
  local bin=""; if command -v speedtest >/dev/null 2>&1; then bin="speedtest"
  elif command -v speedtest-cli >/dev/null 2>&1; then bin="speedtest-cli"; fi
  if [[ -z $bin ]]; then record_result "$id" WARN "Отсутствует speedtest утилита"; TEST_DURATION_MS[$id]=0; return; fi
  local i out d_u d_d d_p ping median_down median_up median_ping
  for ((i=1;i<=RUNS;i++)); do
    if [[ $bin == speedtest ]]; then
      out=$(timeout $TIMEOUT_SEC speedtest --accept-license --accept-gdpr -f json 2>/dev/null || true)
      d_d=$(echo "$out" | grep '"download"' | head -1 | grep -o '"bandwidth":[0-9]+' | cut -d: -f2)
      d_u=$(echo "$out" | grep '"upload"' | head -1 | grep -o '"bandwidth":[0-9]+' | cut -d: -f2)
      d_p=$(echo "$out" | grep -o '"latency":\{"iqm":[0-9.]*' | grep -o '[0-9.]*$')
      # bandwidth в бит/с /8 -> bytes. Преобразуем в Mbps
      if [[ -n $d_d ]]; then d_d=$(awk -v b=$d_d 'BEGIN{printf "%.2f", b*8/1000000}') ; fi
      if [[ -n $d_u ]]; then d_u=$(awk -v b=$d_u 'BEGIN{printf "%.2f", b*8/1000000}') ; fi
    else
      out=$(timeout $TIMEOUT_SEC speedtest-cli --json 2>/dev/null || true)
      d_d=$(echo "$out" | grep 'download' | head -1 | grep -o '[0-9]\+' | head -1)
      d_u=$(echo "$out" | grep 'upload' | head -1 | grep -o '[0-9]\+' | head -1)
      d_p=$(echo "$out" | grep 'ping' | head -1 | grep -o '[0-9.]\+')
      if [[ -n $d_d ]]; then d_d=$(awk -v b=$d_d 'BEGIN{printf "%.2f", b/1000000}') ; fi
      if [[ -n $d_u ]]; then d_u=$(awk -v b=$d_u 'BEGIN{printf "%.2f", b/1000000}') ; fi
    fi
    [[ -n $d_d || -n $d_u ]] || continue
    SPEEDTEST_RESULTS+=("$d_d,$d_u,$d_p")
  done
  if ((${#SPEEDTEST_RESULTS[@]}==0)); then
    record_result "$id" WARN "Нет результатов speedtest" runs="$RUNS"; TEST_DURATION_MS[$id]=0; return
  fi
  # Медианы
  local downs ups pings
  downs=$(printf '%s\n' "${SPEEDTEST_RESULTS[@]}" | cut -d, -f1 | sort -n)
  ups=$(printf '%s\n' "${SPEEDTEST_RESULTS[@]}" | cut -d, -f2 | sort -n)
  pings=$(printf '%s\n' "${SPEEDTEST_RESULTS[@]}" | cut -d, -f3 | sort -n)
  local mid=$(( (${#SPEEDTEST_RESULTS[@]} +1)/2 ))
  median_down=$(echo "$downs" | sed -n "${mid}p")
  median_up=$(echo "$ups" | sed -n "${mid}p")
  median_ping=$(echo "$pings" | sed -n "${mid}p")
  record_result "$id" OK "Speedtest выполнен" median_down_Mbps="$median_down" median_up_Mbps="$median_up" median_ping_ms="$median_ping" runs="${#SPEEDTEST_RESULTS[@]}"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_latency() {
  local id=latency; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local hosts=(1.1.1.1 8.8.8.8) h avg all="" status=OK
  for h in "${hosts[@]}"; do
    if out=$(ping -c5 -w8 "$h" 2>/dev/null); then
      avg=$(echo "$out" | awk -F/ 'END{print $5}')
      all+="$h=$avg,";
    else
      status=INFO
    fi
  done
  record_result "$id" "$status" "Latency измерена" values="${all%,}"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_logs() {
  local id=logs; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local cid=$(docker ps -aqf "name=^${CONTAINER_NAME}$" || true)
  if [[ -z $cid ]]; then record_result "$id" INFO "Нет контейнера"; TEST_DURATION_MS[$id]=0; return; fi
  local logs=$(docker logs --tail 200 "$cid" 2>/dev/null || true)
  echo "$logs" | mask_secrets >"$TMP_DIR/logs_masked.txt"
  local fatal_count=$(echo "$logs" | grep -Eio "$LOG_PATTERN_FATAL_FAIL_REGEX" | wc -l || echo 0)
  local warn_count=$(echo "$logs" | grep -Eio "$LOG_PATTERN_WARN_REGEX" | wc -l || echo 0)
  local status=OK msg="Логи собраны"
  if (( fatal_count > 0 )); then status=FAIL; msg="Найдены критические ошибки"; fi
  if (( warn_count > 0 && status != FAIL )); then status=WARN; msg="Есть предупреждения"; fi
  record_result "$id" "$status" "$msg" fatal_count="$fatal_count" warn_count="$warn_count"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_cresources() {
  local id=resources; id=сresources # кириллица не мешает? лучше латиница - оставим сresources
  id=сresources
  local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local cid=$(docker ps -aqf "name=^${CONTAINER_NAME}$" || true)
  if [[ -z $cid ]]; then record_result "cresources" INFO "Нет контейнера"; TEST_DURATION_MS[cresources]=0; return; fi
  local stats=$(docker stats --no-stream --format '{{.CPUPerc}} {{.MemUsage}} {{.MemPerc}} {{.Name}}' "$cid" 2>/dev/null || true)
  local cpu=$(echo "$stats" | awk '{print $1}')
  local mem=$(echo "$stats" | awk '{print $2" "$3}')
  local memperc=$(echo "$stats" | awk '{print $3}')
  local limits=$(docker inspect -f 'CPUS={{.HostConfig.NanoCpus}} MEM={{.HostConfig.Memory}}' "$cid" 2>/dev/null || true)
  local status=OK msg="Ресурсы собраны"; if [[ $EXPECT_LIMITS -eq 1 ]]; then
    if echo "$limits" | grep -q 'NanoCpus=0'; then status=WARN; msg="Нет CPU лимита"; fi
    if echo "$limits" | grep -q 'Memory=0'; then status=WARN; msg+=" / нет Memory лимита"; fi
  fi
  record_result "cresources" "$status" "$msg" cpu="$cpu" mem="$mem" limits="$limits"
  TEST_DURATION_MS[cresources]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_openports() {
  local id=openports; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local ss_port=$(echo "${TEST_KV[ss_port]}" | grep -o '"port":"[0-9]+"' | grep -o '[0-9]+' || true)
  local list="" status=OK msg="Порты собраны" unexpected=""
  if command -v nmap >/dev/null 2>&1; then
    list=$(nmap -Pn -T4 --min-rate=500 --top-ports 1000 127.0.0.1 2>/dev/null | grep '/tcp' | awk '{print $1}' | cut -d/ -f1 | tr '\n' ',')
  else
    list=$(ss -ltn 2>/dev/null | awk 'NR>1{gsub(/.*:/,"");print $4}' | sort -n | uniq | tr '\n' ',')
  fi
  IFS=',' read -r -a arr <<<"${list%,}"
  for p in "${arr[@]}"; do
    [[ -z $p ]] && continue
    if [[ $p != "22" && $p != "$ss_port" ]]; then unexpected+="$p,"; fi
  done
  if [[ -n $unexpected ]]; then status=WARN; msg="Найдены лишние порты"; RECOMMENDATIONS+=("Закрыть лишние открытые порты: ${unexpected%,}") ; fi
  record_result "$id" "$status" "$msg" open="${list%,}" unexpected="${unexpected%,}" ss_port="$ss_port"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_masking() {
  local id=masking; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local sample="ss://YWFhYmJiY2NjZGRkZWVlZmZmQDEyMy4xMjMuMTIzLjEyMzoxMjM0NQ==@"; local masked
  masked=$(echo "$sample" | mask_secrets)
  if [[ "$masked" == *"***@"* ]]; then
    record_result "$id" OK "Маскирование работает" sample_masked="$masked"
  else
    record_result "$id" FAIL "Маскирование не прошло" sample_masked="$masked"
  fi
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_jsonbuild() {
  local id=jsonbuild; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  # Реальная сборка в output_json, здесь просто заглушка об успешной подготовке
  record_result "$id" OK "Подготовка структуры JSON"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_summary() {
  local id=summary; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local ok=0 warn=0 fail=0 info=0 k
  for k in "${!TEST_STATUS[@]}"; do
    case "${TEST_STATUS[$k]}" in
      OK) ((ok++));; WARN) ((warn++));; FAIL) ((fail++));; INFO) ((info++));; esac
  done
  local worst=OK
  if (( fail>0 )); then worst=FAIL; EXIT_CODE=2
  elif (( warn>0 )); then worst=WARN; EXIT_CODE=1
  else EXIT_CODE=0; fi
  record_result "$id" "$worst" "Итог: OK=$ok WARN=$warn FAIL=$fail INFO=$info" ok=$ok warn=$warn fail=$fail info=$info
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
}

test_selfcheck() {
  local id=selfcheck; local t0=$(date +%s%3N 2>/dev/null || date +%s000)
  local status=OK msg="Self-check пройден"
  # Требования
  if ((${#TEST_STATUS[@]}<5)); then status=FAIL; msg="Мало тестов"; fi
  if [[ $DO_SPEEDTEST -eq 1 ]]; then
    if ((${#SPEEDTEST_RESULTS[@]}==0)); then status=FAIL; msg="Нет результатов speedtest"; fi
  fi
  # Проверка незамаскированных ss:// в логах
  if grep -q 'ss://' "$TMP_DIR/logs_masked.txt" 2>/dev/null; then
    if grep -Eq 'ss://[A-Za-z0-9+/_=-]{10,}@' "$TMP_DIR/logs_masked.txt"; then status=FAIL; msg="Незамаскированы секреты в логах"; fi
  fi
  SELF_CHECK_STATUS=$status
  record_result "$id" "$status" "$msg" speedtests="${#SPEEDTEST_RESULTS[@]}"
  TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-t0))
  if [[ $status == FAIL ]]; then EXIT_CODE=2; fi
}

################################################################################
# ВЫПОЛНЕНИЕ ТЕСТОВ
################################################################################
run_tests() {
  local i fname id
  for i in "${!TESTS[@]}"; do
    fname="${TESTS[$i]}"; id="${fname#test_}"; local tstart=$(date +%s%3N 2>/dev/null || date +%s000)
    if declare -f "$fname" >/dev/null 2>&1; then
      "$fname" || record_result "$id" FAIL "Исключение при выполнении"
    else
      record_result "$id" FAIL "Функция не найдена"
    fi
    # Если не записана длительность — вычислим здесь
    if [[ -z ${TEST_DURATION_MS[$id]:-} ]]; then TEST_DURATION_MS[$id]=$(($(date +%s%3N 2>/dev/null || date +%s000)-tstart)); fi
  done
}

################################################################################
# ВЫВОД JSON
################################################################################
output_json() {
  local entries="" id kv
  for id in "${!TEST_STATUS[@]}"; do
    kv=${TEST_KV[$id]}
    entries+="\"$id\":{\"status\":\"${TEST_STATUS[$id]}\",\"message\":\"$(json_escape "${TEST_MSG[$id]}")\",\"duration_ms\":${TEST_DURATION_MS[$id]:-0}${kv:+,$kv}},"
  done
  entries="${entries%,}"
  local json="{\n  \"version\": \"$VERSION\",\n  \"start_ts\": $START_TS,\n  \"tests\": { $entries }\n}"
  echo -e "$json" >"$TMP_DIR/result.json"
  if command -v jq >/dev/null 2>&1; then
    if ! jq empty "$TMP_DIR/result.json" 2>/dev/null; then
      echo "WARN: JSON validation failed" >&2
    fi
  fi
  cat "$TMP_DIR/result.json"
}

################################################################################
# ВЫВОД ANSI (лаконичный)
################################################################################
output_ansi() {
  local header="ТЕСТ                              | СТАТУС | СООБЩЕНИЕ"
  printf "%s\n" "$header"
  printf -- "------------------------------------+--------+------------------------------\n"
  local id status color line
  for id in "${!TEST_STATUS[@]}"; do
    status=${TEST_STATUS[$id]}
    case $status in
      OK) color=$GREEN;; WARN) color=$YELLOW;; FAIL) color=$RED;; INFO) color=$BLUE;; *) color=$RESET;; esac
    printf "%-34s | %s%-6s%s | %s\n" "$id" "$color" "$status" "$RESET" "${TEST_MSG[$id]}"
  done | sort
  echo
  echo "Рекомендации:"
  if ((${#RECOMMENDATIONS[@]})); then
    printf ' - %s\n' "${RECOMMENDATIONS[@]}" | sort -u
  else
    echo " (нет дополнительных рекомендаций)"
  fi
}

################################################################################
# ОСНОВНОЙ ПОТОК
################################################################################
main() {
  init_environment
  run_tests
  test_summary
  test_selfcheck
  if [[ $JSON_ONLY -eq 0 ]]; then
    output_ansi | mask_secrets
  fi
  output_json | mask_secrets
  exit $EXIT_CODE
}

main "$@"